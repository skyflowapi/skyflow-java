/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.skyflow.generated.rest.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.skyflow.generated.rest.core.ObjectMappers;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = DetectRunsResponse.Builder.class)
public final class DetectRunsResponse {
    private final Optional<DetectRunsResponseStatus> status;

    private final Optional<DetectRunsResponseOutputType> outputType;

    private final Optional<List<DeidentifiedFileOutput>> output;

    private final Optional<String> message;

    private final Optional<Float> size;

    private final Optional<WordCharacterCount> wordCharacterCount;

    private final Optional<Float> duration;

    private final Optional<Integer> pages;

    private final Optional<Integer> slides;

    private final Map<String, Object> additionalProperties;

    private DetectRunsResponse(
            Optional<DetectRunsResponseStatus> status,
            Optional<DetectRunsResponseOutputType> outputType,
            Optional<List<DeidentifiedFileOutput>> output,
            Optional<String> message,
            Optional<Float> size,
            Optional<WordCharacterCount> wordCharacterCount,
            Optional<Float> duration,
            Optional<Integer> pages,
            Optional<Integer> slides,
            Map<String, Object> additionalProperties) {
        this.status = status;
        this.outputType = outputType;
        this.output = output;
        this.message = message;
        this.size = size;
        this.wordCharacterCount = wordCharacterCount;
        this.duration = duration;
        this.pages = pages;
        this.slides = slides;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Status of the operation.
     */
    @JsonProperty("status")
    public Optional<DetectRunsResponseStatus> getStatus() {
        return status;
    }

    /**
     * @return Format of the output file.
     */
    @JsonProperty("outputType")
    public Optional<DetectRunsResponseOutputType> getOutputType() {
        return outputType;
    }

    /**
     * @return Details of output files. Files are specified as Base64-encoded data.
     */
    @JsonProperty("output")
    public Optional<List<DeidentifiedFileOutput>> getOutput() {
        return output;
    }

    /**
     * @return Status details about the Detect run.
     */
    @JsonProperty("message")
    public Optional<String> getMessage() {
        return message;
    }

    /**
     * @return Size of the processed file in kilobytes (KB).
     */
    @JsonProperty("size")
    public Optional<Float> getSize() {
        return size;
    }

    @JsonProperty("wordCharacterCount")
    public Optional<WordCharacterCount> getWordCharacterCount() {
        return wordCharacterCount;
    }

    /**
     * @return Duration of the processed audio in seconds.
     */
    @JsonProperty("duration")
    public Optional<Float> getDuration() {
        return duration;
    }

    /**
     * @return Number of pages in the processed PDF.
     */
    @JsonProperty("pages")
    public Optional<Integer> getPages() {
        return pages;
    }

    /**
     * @return Number of slides in the processed presentation.
     */
    @JsonProperty("slides")
    public Optional<Integer> getSlides() {
        return slides;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof DetectRunsResponse && equalTo((DetectRunsResponse) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(DetectRunsResponse other) {
        return status.equals(other.status)
                && outputType.equals(other.outputType)
                && output.equals(other.output)
                && message.equals(other.message)
                && size.equals(other.size)
                && wordCharacterCount.equals(other.wordCharacterCount)
                && duration.equals(other.duration)
                && pages.equals(other.pages)
                && slides.equals(other.slides);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.status,
                this.outputType,
                this.output,
                this.message,
                this.size,
                this.wordCharacterCount,
                this.duration,
                this.pages,
                this.slides);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<DetectRunsResponseStatus> status = Optional.empty();

        private Optional<DetectRunsResponseOutputType> outputType = Optional.empty();

        private Optional<List<DeidentifiedFileOutput>> output = Optional.empty();

        private Optional<String> message = Optional.empty();

        private Optional<Float> size = Optional.empty();

        private Optional<WordCharacterCount> wordCharacterCount = Optional.empty();

        private Optional<Float> duration = Optional.empty();

        private Optional<Integer> pages = Optional.empty();

        private Optional<Integer> slides = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(DetectRunsResponse other) {
            status(other.getStatus());
            outputType(other.getOutputType());
            output(other.getOutput());
            message(other.getMessage());
            size(other.getSize());
            wordCharacterCount(other.getWordCharacterCount());
            duration(other.getDuration());
            pages(other.getPages());
            slides(other.getSlides());
            return this;
        }

        /**
         * <p>Status of the operation.</p>
         */
        @JsonSetter(value = "status", nulls = Nulls.SKIP)
        public Builder status(Optional<DetectRunsResponseStatus> status) {
            this.status = status;
            return this;
        }

        public Builder status(DetectRunsResponseStatus status) {
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * <p>Format of the output file.</p>
         */
        @JsonSetter(value = "outputType", nulls = Nulls.SKIP)
        public Builder outputType(Optional<DetectRunsResponseOutputType> outputType) {
            this.outputType = outputType;
            return this;
        }

        public Builder outputType(DetectRunsResponseOutputType outputType) {
            this.outputType = Optional.ofNullable(outputType);
            return this;
        }

        /**
         * <p>Details of output files. Files are specified as Base64-encoded data.</p>
         */
        @JsonSetter(value = "output", nulls = Nulls.SKIP)
        public Builder output(Optional<List<DeidentifiedFileOutput>> output) {
            this.output = output;
            return this;
        }

        public Builder output(List<DeidentifiedFileOutput> output) {
            this.output = Optional.ofNullable(output);
            return this;
        }

        /**
         * <p>Status details about the Detect run.</p>
         */
        @JsonSetter(value = "message", nulls = Nulls.SKIP)
        public Builder message(Optional<String> message) {
            this.message = message;
            return this;
        }

        public Builder message(String message) {
            this.message = Optional.ofNullable(message);
            return this;
        }

        /**
         * <p>Size of the processed file in kilobytes (KB).</p>
         */
        @JsonSetter(value = "size", nulls = Nulls.SKIP)
        public Builder size(Optional<Float> size) {
            this.size = size;
            return this;
        }

        public Builder size(Float size) {
            this.size = Optional.ofNullable(size);
            return this;
        }

        @JsonSetter(value = "wordCharacterCount", nulls = Nulls.SKIP)
        public Builder wordCharacterCount(Optional<WordCharacterCount> wordCharacterCount) {
            this.wordCharacterCount = wordCharacterCount;
            return this;
        }

        public Builder wordCharacterCount(WordCharacterCount wordCharacterCount) {
            this.wordCharacterCount = Optional.ofNullable(wordCharacterCount);
            return this;
        }

        /**
         * <p>Duration of the processed audio in seconds.</p>
         */
        @JsonSetter(value = "duration", nulls = Nulls.SKIP)
        public Builder duration(Optional<Float> duration) {
            this.duration = duration;
            return this;
        }

        public Builder duration(Float duration) {
            this.duration = Optional.ofNullable(duration);
            return this;
        }

        /**
         * <p>Number of pages in the processed PDF.</p>
         */
        @JsonSetter(value = "pages", nulls = Nulls.SKIP)
        public Builder pages(Optional<Integer> pages) {
            this.pages = pages;
            return this;
        }

        public Builder pages(Integer pages) {
            this.pages = Optional.ofNullable(pages);
            return this;
        }

        /**
         * <p>Number of slides in the processed presentation.</p>
         */
        @JsonSetter(value = "slides", nulls = Nulls.SKIP)
        public Builder slides(Optional<Integer> slides) {
            this.slides = slides;
            return this;
        }

        public Builder slides(Integer slides) {
            this.slides = Optional.ofNullable(slides);
            return this;
        }

        public DetectRunsResponse build() {
            return new DetectRunsResponse(
                    status,
                    outputType,
                    output,
                    message,
                    size,
                    wordCharacterCount,
                    duration,
                    pages,
                    slides,
                    additionalProperties);
        }
    }
}
